/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.aliyun.homeshell;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Point;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Environment;
import android.support.v4.view.PagerAdapter;
import android.text.Editable;
import android.text.InputType;
import android.text.TextWatcher;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.LinearInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.aliyun.homeshell.Alarm.OnAlarmListener;
import com.aliyun.homeshell.FolderInfo.FolderListener;
import com.aliyun.homeshell.LauncherSettings.Favorites;
import com.aliyun.homeshell.appclone.HintDialogUitils;
import com.aliyun.homeshell.gadgets.HomeShellGadgetsRender;
import com.aliyun.homeshell.hideseat.Hideseat;
import com.aliyun.homeshell.icon.BubbleController;
import com.aliyun.homeshell.icon.BubbleTextView;
import com.aliyun.homeshell.icon.IconManager;
import com.aliyun.homeshell.model.LauncherModel;
import com.aliyun.homeshell.setting.HomeShellSetting;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource, View.OnClickListener,
        View.OnLongClickListener, DropTarget, FolderListener, TextView.OnEditorActionListener, DragScroller,
        View.OnFocusChangeListener {
    private static final String TAG = "Launcher.Folder";

    protected DragController mDragController;
    protected Launcher mLauncher;
    protected FolderInfo mInfo;

    public static final int STATE_NONE = -1;
    public static final int STATE_SMALL = 0;
    public static final int STATE_ANIMATING = 1;
    public static final int STATE_OPEN = 2;
    private final int MAX_ITEMS_COUNT = 1000;

    private int mExpandDuration;
    private CellLayout mContent;
    private final LayoutInflater mInflater;
    private volatile int mState = STATE_NONE;
    private static final int REORDER_ANIMATION_DURATION = 230;

    /* YUNOS BEGIN */
    // ##date:2013/12/06 ##author:zhangqiang.zq
    // 70513 : ON_EXIT_CLOSE_DELAY change from 800 to 100
    private static final int ON_EXIT_CLOSE_DELAY = 100;
    /* YUNOS END */

    private boolean mRearrangeOnClose = false;
    private FolderIcon mFolderIcon;
    private int mMaxCountX;
    private int mMaxCountY;
    //private int mMaxItemsCountPerPage;
    //private int mMaxNumItems;
    private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
    private Drawable mIconDrawable;
    boolean mItemsInvalidated = false;
    private ShortcutInfo mCurrentDragInfo;
    private View mCurrentDragView;
    boolean mSuppressOnAdd = false;
    private int[] mTargetCell = new int[2];
    private int[] mPreviousTargetCell = new int[2];
    private int[] mEmptyCell = new int[2];
    private Alarm mReorderAlarm = new Alarm();
    private Alarm mOnExitAlarm = new Alarm();
    private int mFolderNameHeight;
    private int mFolderNameContentGap;
    private Rect mTempRect = new Rect();
    private boolean mDragInProgress = false;
    private boolean mDeleteFolderOnDropCompleted = false;
    private boolean mSuppressFolderDeletion = false;
    private boolean mItemAddedBackToSelfViaIcon = false;
    FolderEditText mFolderName;
    private float mFolderIconPivotX;
    private float mFolderIconPivotY;
    private FolderAppsSelectView mAppsSelectView;
    private AnimatorSet mRunningAnimatorSet = null;
    private boolean mRunningIsShow = false;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private static String sDefaultFolderName;
    // private static String sHintText;
    //private Animator mOpenCloseAnimator;

    private boolean mDestroyed;
    /* YUNOS BEGIN */
    // ##date:2013/11/25 ##author:xiaodong.lxd
    // true : drop accepted ; false : drop rejected
    //private boolean mDropAccepted = false;
    protected ShortcutInfo mShortcutInfoCache = null;
    protected boolean mHasDirtyData = false;
    /* YUNOS END */
    /*YUNOS BEGIN*/
    //##date:2014/9/25 ##author:yangshan.ys BugId:5255762
    private int mAnimatorDuration = 300;
    private ArrayList<CellLayout> mContentList = new ArrayList<CellLayout>();
    private FolderSelectPager mFolderViewPager;
    private PagerAdapter mContentAdapter;
    private PageIndicatorView mPageIndicator;
    private boolean mDragExit = false;
    private boolean mScrolling = false;
    private int mLastOrientation;
    /*YUNOS END*/

    /* YUNOS BEGIN */
    //##date:2014/09/23 ##author:andy.zx ##BugID:5244732
    /**
     * used for get the screen's width and height
     */
    private Point mDisplaySize = new Point();
    /* YUNOS END */

    /* YUNOS BEGIN */
    // ##date:2015/1/30 ##author:zhanggong.zg ##BugID:5744899
    // Enables dragging icon out of folder through left and right edge.
    // Reset in onDragEnter() and modified in scrollLeft() and scrollRight().
    private boolean mDraggingToLeftEdge = false;
    private boolean mDraggingToRightEdge = false;
    /* YUNOS END */

    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);
        setAlwaysDrawnWithCacheEnabled(false);
        mInflater = LayoutInflater.from(context);

        /* YUNOS BEGIN */
        //##date:2014/04/16 ##author:nater.wg ##BugID:110407
        // Enhance ConfigManager.
/*
        Resources res = getResources();
        mMaxCountX = res.getInteger(R.integer.folder_max_count_x);
        mMaxCountY = res.getInteger(R.integer.folder_max_count_y);
        mMaxNumItems = res.getInteger(R.integer.folder_max_num_items);
        if (mMaxCountX < 0 || mMaxCountY < 0 || mMaxNumItems < 0) {
            mMaxCountX = LauncherModel.getCellCountX();
            mMaxCountY = LauncherModel.getCellCountY();
            mMaxNumItems = mMaxCountX * mMaxCountY;
        }
*/
        mLauncher = (Launcher) context;
        mIconManager = mLauncher.getIconManager();
        mMaxCountX = ConfigManager.getFolderMaxCountX();
        mMaxCountY = ConfigManager.getFolderMaxCountY();
        //mMaxNumItems = mMaxCountX * mMaxCountY;
        /* YUNOS END */

        Resources res = getResources();
        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

        mExpandDuration = res.getInteger(R.integer.config_folderAnimDuration);

        if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }
        /*
         * if (sHintText == null) { sHintText =
         * res.getString(R.string.folder_hint_text); }
         */
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
        
        mShortcutInfoCache = new ShortcutInfo();
        
        /* YUNOS BEGIN */
        //##date:2014/09/23 ##author:andy.zx ##BugID:5244732
        Display display = mLauncher.getWindowManager().getDefaultDisplay();
        display.getSize(mDisplaySize);
        /* YUNOS END */
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        setContent((CellLayout) findViewById(R.id.folder_content));
        mContent.setGridSize(0, 0);
        mContent.getShortcutAndWidgetContainer().setMotionEventSplittingEnabled(false);
        mContent.setInvertIfRtl(true);
        mContentList.add(mContent);
        mFolderName = (FolderEditText) findViewById(R.id.folder_name);
        mFolderName.setFolder(this);
        mFolderName.setOnFocusChangeListener(this);
        /*YUNOS BEGIN*/
        //##date:2014/9/25 ##author:yangshan.ys BugId:5255762
        mContentAdapter = new FolderContentAdapter();
        mFolderViewPager = (FolderSelectPager) findViewById(R.id.folder_view_pager);
        mFolderViewPager.setOffscreenPageLimit(40);
        mFolderViewPager.setAdapter(mContentAdapter);
        mFolderViewPager.setOnPageChangeListener(pageChangeListener);
        mFolderViewPager.setOnClickListener(this);
        mPageIndicator = (PageIndicatorView) findViewById(R.id.folder_page_indicator);
        mPageIndicator.setNeedLine(false);
        /*YUNOS END*/
        // We find out how tall the text view wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        int measureSpec = MeasureSpec.UNSPECIFIED;
        mFolderName.measure(measureSpec, measureSpec);
        /*YUNOS BEGIN*/
        //##module(component name)
        //##date:2014/06/06 ##author:jun.dongj@alibaba-inc.com##BugID:124683
        //folder name show wrong, when the system font is super big
        mFolderNameHeight = mFolderName.getMeasuredHeight();
        /*YUNOS END*/
 
        mFolderNameContentGap = getResources().getDimensionPixelSize(R.dimen.folder_name_content_gap);
        // We disable action mode for now since it messes up the view on phones
        mFolderName.setOnEditorActionListener(this);
        mFolderName.addTextChangedListener(new TextWatcher() {
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {

            }
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            }
            @Override
            public void afterTextChanged(Editable s) {
                mFolderName.requestLayout();
            }
        });
        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        showFolderNameOutline(false);
        updateFolderLayout(mIconManager.supprtCardIcon());
        mLastOrientation = getResources().getConfiguration().orientation;
    }

    @Override
    protected void onAttachedToWindow() {
        updateOrientation();
        mContent = mContentList.get(0);
        mContent.setLayerType(LAYER_TYPE_NONE, null);
        super.onAttachedToWindow();
        mLauncher.getDragController().setDragScoller(this);
        mLauncher.getDragController().setScrollView(mFolderViewPager);
        mDragExit = false;
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        mIsEditingName = false;
        mLauncher.getDragController().setDragScoller(mLauncher.getWorkspace());
        mLauncher.getDragController().setScrollView(mLauncher.getDragLayer());
    }

    public void setFolderLayout(boolean small) {
        final int w, h, wg, hg, l, t, r, b, countX, countY;
        Resources res = getResources();
        if (AgedModeUtil.isAgedMode()) {
            w = res.getDimensionPixelSize(R.dimen.bubble_icon_width_3_3);
            h = res.getDimensionPixelSize(R.dimen.bubble_icon_height_3_3);
            if (small) {
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap_small);
                hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_small);
            } else {
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                hg = (int) (res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_3_3) * 0.5);
            }
            l = res.getDimensionPixelSize(R.dimen.folder_cell_layout_start_padding_3_3);
            t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
            r = res.getDimensionPixelSize(R.dimen.folder_cell_layout_end_padding_3_3);
            b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding_3_3);
        } else {
            w = res.getDimensionPixelSize(R.dimen.folder_cell_width_small);
            h = res.getDimensionPixelSize(R.dimen.folder_cell_height_small);
            if (small) {
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap_small);
                hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_small);
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
            } else {
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                hg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding);
            }
            l = mContent.getPaddingLeft();
            r = mContent.getPaddingRight();
            b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding);
        }
        countX = mMaxCountX;
        countY = ConfigManager.getFolderMaxCountY();
        mContentWidth = countX * w + (countX - 1) * wg + l + r;
        mContentHeight = countY * h + (countY - 1) * hg + t + b;
        for (CellLayout mContent : mContentList) {
            mContent.setCellSize(w, h, wg, hg, true);
            mContent.setPadding(l, t, r, b);
        }
    }

    private void updateFolderLayout(boolean supportCardIcon){
        final int w, h, wg, hg, l, t, r, b, countX, countY;
        Resources res = getResources();
        if (supportCardIcon) {
        /* YUNOS BEGIN */
        // ##date:2014/10/16 ##author:yangshan.ys##5157204
        // for 3*3 layout
            if (AgedModeUtil.isAgedMode()) {
                w = res.getDimensionPixelSize(R.dimen.bubble_icon_width_3_3);
                h = res.getDimensionPixelSize(R.dimen.bubble_icon_height_3_3);
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                hg = (int) (res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_3_3) * 0.5);
                l = res.getDimensionPixelSize(R.dimen.folder_cell_layout_start_padding_3_3);
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
                r = res.getDimensionPixelSize(R.dimen.folder_cell_layout_end_padding_3_3);
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding_3_3);
            } else {
                w = res.getDimensionPixelSize(R.dimen.folder_cell_width);
                h = res.getDimensionPixelSize(R.dimen.folder_cell_height);
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap);
                l = mContent.getPaddingLeft();
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding);
                r = mContent.getPaddingRight();
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding);
            }
            countX = mMaxCountX;
        } else {
        /* YUNOS BEGIN */
        // ##date:2014/10/16 ##author:yangshan.ys##5157204
        // for 3*3 layout
            if (AgedModeUtil.isAgedMode()) {
                w = res.getDimensionPixelSize(R.dimen.bubble_icon_width_3_3);
                h = res.getDimensionPixelSize(R.dimen.bubble_icon_height_3_3);
                if (mLauncher.mFolderUtils.isFolderOpened()) {
                    wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                    hg = (int) (res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_3_3) * 0.5);
                } else {
                    wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap_small);
                    hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_small);
                }
                l = res.getDimensionPixelSize(R.dimen.folder_cell_layout_start_padding_3_3);
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
                r = res.getDimensionPixelSize(R.dimen.folder_cell_layout_end_padding_3_3);
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding_3_3);
        /*YUNOS END*/
            } else {
                w = res.getDimensionPixelSize(R.dimen.folder_cell_width_small);
                h = res.getDimensionPixelSize(R.dimen.folder_cell_height_small);
                if (mLauncher.mFolderUtils.isFolderOpened()) {
                    wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                    hg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                    t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding);
                } else {
                    wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap_small);
                    hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_small);
                    t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
                }
                l = mContent.getPaddingLeft();
                r = mContent.getPaddingRight();
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding);
            }
            countX = mMaxCountX;
        }
        countY = ConfigManager.getFolderMaxCountY();
        mContentWidth = countX * w + (countX - 1) * wg + l + r;
        mContentHeight = countY * h + (countY - 1) * hg + t + b;
        for (CellLayout mContent : mContentList) {
            mContent.setCellSize(w, h, wg, hg, true);
            mContent.setPadding(l, t, r, b);
        }
    }

    float mIconScale, mIconPaddingX, mIconPaddingY;
    boolean mSupportCardIcon, mSinglePage, mHotSeat;
    int mIconChild, mContentHeight, mContentWidth, mDrawingLimit, mPageCount, mLastDesireWidth;
    IconManager mIconManager;

    void drawFolderIcon(Canvas c, int w, int h, float padding, float contentPadding, boolean hotSeat) {
        CellLayout mContent = mContentList.get(0);
        boolean supportCard = isSupportCardIcon();
        int count = mContent.getShortcutAndWidgetContainer().getChildCount();
        int desireWidth = mContent.getDesiredWidth();
        /* YUNOS BEGIN */
        // ##date:2015/1/15 ##author:yangshan.ys##5696074
        // avoid the unsynchronized between folderIcon and bubbleTextView in
        // folderIcon
        if (mSupportCardIcon != supportCard && !Launcher.sReloadingForThemeChangeg) {
            updateFolderLayout(supportCard);
            mSupportCardIcon = supportCard;
        }
        /* YUNOS END */
        updateOrientation();
        int countX = mContent.getCountX();
        int cellWidth = mContent.getCellWidth();
        int cellHeight = mContent.getCellHeight();
        int widthGap = ConfigManager.isLandOrienSupport() ? 0 : mContent.getWidthGap();
        int heightGap= ConfigManager.isLandOrienSupport() ? 0 : mContent.getHeightGap();
        int topPadding = mContent.getPaddingTop();
        int startPadding = mContent.getPaddingStart();
        mHotSeat = hotSeat;
        mIconChild = count;
        mLastDesireWidth = desireWidth;
        int contentWidth = mContent.getDesiredWidth() - (ConfigManager.isLandOrienSupport() ?
                (mContent.getCountX() - 1) * mContent.getWidthGap() : 0);
        float iconScale;
        if (mSupportCardIcon) {
            if (!AgedModeUtil.isAgedMode()) {
                iconScale = (float) w / contentWidth;
                padding = (int) (startPadding * iconScale);
                mIconPaddingX = contentPadding;
            } else {
                iconScale = (w - 2 * contentPadding) / contentWidth;
                mIconPaddingX = contentPadding;
            }
            if (!hotSeat)
                mIconPaddingY = contentPadding - iconScale * getFolderNamePadding();
        } else {
            iconScale = (float) (w - padding * 2) /  (contentWidth - startPadding * 2);
            float div = (cellHeight * countX + heightGap * (countX - 1) - cellWidth * countX + widthGap * (countX - 1)) / 2 * iconScale * 0.2f;
            if (AgedModeUtil.isAgedMode()) {
                c.translate(div, 0);
            } else {
                //BugID:8297290:Adjust icon to center in folder.
                //c.translate(div, div);
                c.translate(div / 3, div);
            }
            mIconPaddingX = contentPadding - iconScale * startPadding;
            if(!hotSeat)
                mIconPaddingY = contentPadding - div - iconScale * (getFolderNamePadding() + topPadding);
        }
        if(hotSeat)
            mIconPaddingY = getResources().getDimensionPixelSize(R.dimen.bubble_textview_hotseat_top_padding) - iconScale * getFolderNamePadding();
        mIconScale = iconScale; 

        if (mSupportCardIcon) {
            if (AgedModeUtil.isAgedMode()) {
                c.translate(contentPadding, contentPadding);
            }
            c.clipRect(0, 0, w, h);
        } else
            c.clipRect(0, 0, w - padding * 2, h - padding);

        c.scale(iconScale, iconScale);
        int iconH = (int) (h / iconScale);

        int countY = (iconH - topPadding + heightGap) / (ConfigManager.isLandOrienSupport() ?
                cellWidth + widthGap : cellHeight + heightGap);
        ArrayList<View> icons = getItemsInReadingOrder(false);
        if (mSupportCardIcon)
            c.translate(startPadding, topPadding);
        if (mFolderIcon.mHideIcon)
            return;
        boolean rtl = getResources().getConfiguration().getLayoutDirection() == LAYOUT_DIRECTION_RTL;
        mPageCount = countX * (mSupportCardIcon ? countX : countX + 1);
        mDrawingLimit = Math.min(icons.size(), countX * countY);

        View v = null;
        for (int i = 0, N = mDrawingLimit; i < N; i++) {
            v = icons.get(i);
            if (v != null && v.getTag() == mInfo.getmEditFolderShortcutInfo()) {
                continue;
            }

            int x = (rtl ? (countX - (i % countX) - 1) : (i % countX)) * (cellWidth + widthGap);
            int y = (i / countX) * (ConfigManager.isLandOrienSupport() ? cellWidth : cellHeight + heightGap);

            int widthInFolderIcon = w;
            int heightInFolderIcon = h;
            if (supportCard) {
                // The w & h are the width & height of folderIcon. If draw in hotseat use w & h and in BigCard model,
                // will draw little bubbletextviews which in folder to be square, not rectangle which is we real need.
                // so in BigCard model, we need to use the cellWidth an cellHeight which are get form the CellLayout.
                // but in little card model, we can't use the cellWidth and cellHeight, because cellWidth and cellHeight is
                // big than w and h.
                widthInFolderIcon = cellWidth;
                heightInFolderIcon = cellHeight;
            }
            c.save();
            c.translate(x, y);
            ((BubbleTextView) v).drawBubbleTextViewInFolderIcon(widthInFolderIcon, heightInFolderIcon, c);
            c.restore();
        }
    }

    private void updateOrientation() {
        updateOrientation(getResources().getConfiguration().orientation);
    }

    private void updateOrientation(int orientation) {
        if (mLastOrientation != orientation) {
            for (CellLayout layout : mContentList) {
                layout.onConfigurationChanged(getResources().getConfiguration());
                layout.forceLayout();
            }
            updateFolderLayout(mSupportCardIcon);
            requestLayout();
            mLastOrientation = orientation;
        }
    }

    @Override
    protected void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        updateOrientation(newConfig.orientation);
    }

    float getLocalCenterForIndex(int index, float[] center, int width, boolean extended) {
        float scale = mIconScale;
        if (scale == 0)
            scale = (float) width / mContent.getDesiredWidth();
        int countX = mContent.getCountX();
        int cellWidth = mContent.getCellWidth();
        int cellHeight = mContent.getCellHeight();
        int widthGap = mContent.getWidthGap();
        int heightGap = mContent.getHeightGap();
        int topPadding = mContent.getPaddingTop();
        int leftPadding = mContent.getPaddingLeft();
        int x = index % countX;
        int y = index / countX;
        if(extended)
            x = y = countX / 2;
        else if(getResources().getConfiguration().getLayoutDirection() == LAYOUT_DIRECTION_RTL)
            x = countX - x - 1;
        int centerX = x * (cellWidth + widthGap) + cellWidth / 2 + leftPadding;
        int centerY = y * (cellHeight + heightGap) + cellHeight / 2 + topPadding;
        int margin = mSupportCardIcon && !mHotSeat ? 0 : (width - FolderIcon.mPreiewSize) / 2;
        center[0] = scale * centerX + margin;
        center[1] = scale * centerY + margin;
        return scale;
    }

    public boolean isSupportCardIcon() {
        return mIconManager.supprtCardIcon();
    }

    public int getFolderNamePadding() {
        return mFolderNameHeight + mFolderNameContentGap;
    }

    public FolderIcon getFolderIcon() {
        return mFolderIcon;
    }

    public void scrollUp() {
    }
    public void scrollDown() {
    }
    public void scrollLeft() {
        if (mDragExit)
            return;
        int current = mFolderViewPager.getCurrentItem();
        if (current > 0) {
            this.switchToPage(current - 1);
            this.autoMoveIconByScroll(current, current - 1);
        } else {
            /* YUNOS BEGIN */
            // ##date:2015-1-22 ##author:zhanggong.zg ##BugID:5645766
            // ##date:2015-1-30 ##author:zhanggong.zg ##BugID:5744899
            mDraggingToLeftEdge = true;
            /* YUNOS END */
        }
    }
    public void scrollRight() {
        if (mDragExit)
            return;
        int current = mFolderViewPager.getCurrentItem();
        int count = mFolderViewPager.getAdapter().getCount();
        if (current < count - 1) {
            this.switchToPage(current + 1);
            this.autoMoveIconByScroll(current, current + 1);
        } else {
            /* YUNOS BEGIN */
            // ##date:2015-1-22 ##author:zhanggong.zg ##BugID:5645766
            // ##date:2015-1-30 ##author:zhanggong.zg ##BugID:5744899
            mDraggingToRightEdge = true;
            /* YUNOS END */
        }
    }
    public boolean onEnterScrollArea(int x, int y, int direction) {
        return true;
    }
    public boolean onExitScrollArea() {
        return false;
    }
	//YUNOS END

    public void onClick(View v) {
        // close folder on click
        if(v == mFolderViewPager && !mLauncher.isGadgetCardShowing()) {
            mLauncher.closeFolder();
            return;
        }
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            // refactor this code from Folder
            ShortcutInfo item = (ShortcutInfo) tag;
            /* YUNOS BEGIN */
            // ##date:2014/06/03 ##author:yangshan.ys
            // batch operations to the icons in folder
            if(item.isEditFolderShortcut()) {
                mLauncher.getGestureLayer().setTouchEnabled(false);
                mLauncher.getWorkspace().setFolderBatchOping(this);
                UserTrackerHelper.sendUserReport(UserTrackerMessage.MSG_FOLDER_CLICK_ADDAPP);
                mLauncher.closeFolder();
                mLauncher.postRunnableToMainThread(new Runnable() {
                    @Override
                    public void run() {
                        mLauncher.enterLauncherEditMode();
                        mLauncher.getGestureLayer().setTouchEnabled(true);
                    }
                }, FolderUtils.getFolderCloseDuration() + 50);
            } else {
            /* YUNOS END */
                if (HomeShellGadgetsRender.isOneKeyAccerateShortCut(item)) {
                    mLauncher.startActivitySafely(v, item.intent, tag);
                    ((ShortcutInfo)tag).setIsNewItem(false);
                    BubbleController.updateView((BubbleTextView) v);
                    LauncherModel.modifyItemNewStatusInDatabase(mLauncher, item, false);
                    HomeShellGadgetsRender.getRender().playAccelarateAnimation(mLauncher.getApplicationContext());
                    return;
                }
                /*YUNOS BEGIN*/
                //##date:2013/11/28 ##author:xindong.zxd
                //update folder item status flag
                if (item.isNewItem()) {
                    // ##date:2015/8/4 ##author:zhanggong.zg ##BugID:6277395
                    Launcher.asyncSendFirstLaunchBroadcast(item);
                }
                item.setIsNewItem(false);
                BubbleController.updateView((BubbleTextView) v);
                LauncherModel.modifyItemNewStatusInDatabase(getContext(), item, false);
                Launcher.asyncIncreaseAppLaunchCount(item);
                mFolderIcon.invalidate();
                /*YUNOS END*/
                int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                item.intent.setSourceBounds(new Rect(pos[0], pos[1],
                        pos[0] + v.getWidth(), pos[1] + v.getHeight()));

              	/*YUNOS BEGIN*/
                //##date:2013/12/6 ##author:xindong.zxd
                //avtivity switching when application update
                /*YUNOS BEGIN*/
                //##date:2014/02/19 ##author:hao.liuhaolh ##BugID:92481
                //vp install
// remove vp install
                //item type vpinstall need to be checked before isDownloading
//                if (item.itemType == LauncherSettings.Favorites.ITEM_TYPE_VPINSTALL) {
//                    mLauncher.getModel().startVPSilentInstall(item);
//                }
                /*YUNOS END*/
//else        
                if (item.isDownloading()) {
                    mLauncher.onDownloadingClick(v);
                } else if (HintDialogUitils.needShowAppCloneHintDialog(mLauncher, tag)) {
                    HintDialogUitils.showAppCloneHintDialog(mLauncher, v);
                    return;
                } else {
                    mLauncher.startActivitySafely(v, item.intent, item);
                    /* YUNOS BEGIN */
                    // ##date:2014/8/1 ##author:zhangqiang.zq
                    // favorite app, BugID:1033964
                    if (item.itemType == LauncherSettings.BaseLauncherColumns.ITEM_TYPE_APPLICATION) {
                        ((LauncherApplication) mLauncher.getApplicationContext())
                                .collectUsageData(item.id);
                    }
                    /* YUNOS END */
                }
                /*YUNOS BEGIN*/
            }
        }
    }
	/* YUNOS BEGIN */
    // ##date:2014/06/26 ##author:yangshan.ys
    // show the folderSelectApps when click the EditFolderIcon
    public void showSelectApps(int[] pos) {
        if(mRunningAnimatorSet != null) {
            if(!mRunningIsShow) {
                mRunningAnimatorSet.end();
            } else {
                return;
            }
        }
        if(mAppsSelectView == null) {
            mAppsSelectView = (FolderAppsSelectView)LayoutInflater.from(getContext()).inflate(R.layout.folder_apps_select, null);
            mAppsSelectView.init(this, mInfo, mLauncher);
            mLauncher.getDragLayer().addView(mAppsSelectView);
        }
        mAppsSelectView.initSelectedState(mInfo);
        mAppsSelectView.setScaleX(0);
        mAppsSelectView.setScaleY(0);
        mAppsSelectView.setPivotX(pos[0]);
        mAppsSelectView.setPivotY(pos[1]);
        ObjectAnimator visToInvis = ObjectAnimator.ofFloat(this, "alpha", 1, 0);
        visToInvis.setDuration(mAnimatorDuration);
        ObjectAnimator invisToVisX = ObjectAnimator.ofFloat(mAppsSelectView, "scaleX", 0, 1);
        invisToVisX.setDuration(mAnimatorDuration);
        ObjectAnimator invisToVisY = ObjectAnimator.ofFloat(mAppsSelectView, "scaleY", 0, 1);
        invisToVisY.setDuration(mAnimatorDuration);
        List<Animator> animList = new ArrayList<Animator>();
        animList.add(visToInvis);
        animList.add(invisToVisX);
        animList.add(invisToVisY);
        final AnimatorSet as = new AnimatorSet();
        as.setInterpolator(new LinearInterpolator());
        as.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animator) {
                mAppsSelectView.setVisibility(View.VISIBLE);
                mRunningAnimatorSet = as;
                mRunningIsShow = true;
            }
            @Override
            public void onAnimationEnd(Animator animator) {
                mRunningAnimatorSet = null;
                mRunningIsShow = false;
                Folder.this.setVisibility(View.INVISIBLE);
                mAppsSelectView.setVisibility(View.VISIBLE);
                DisplayMetrics metric = new DisplayMetrics();
                mLauncher.getWindowManager().getDefaultDisplay().getMetrics(metric);
                int width = metric.widthPixels;
                int height = metric.heightPixels;
                mAppsSelectView.setPivotX(width/2);
                mAppsSelectView.setPivotY(height/2);
                mAppsSelectView.setFocusableInTouchMode(true);
                mAppsSelectView.setFocusable(true);
                mAppsSelectView.requestFocus();
            }
        });
        as.playTogether(animList);
        as.start();
    }
    public AnimatorSet getmRunningAnimatorSet() {
        return mRunningAnimatorSet;
    }

    public void setmRunningAnimatorSet(AnimatorSet mRunningAnimatorSet) {
        this.mRunningAnimatorSet = mRunningAnimatorSet;
    }

    public boolean ismRunningIsShow() {
        return mRunningIsShow;
    }

    public void setmRunningIsShow(boolean mRunningIsShow) {
        this.mRunningIsShow = mRunningIsShow;
    }
    /* YUNOS END */
    public boolean onLongClick(View v) {
        // Return if global dragging is not enabled
        if (!mLauncher.isDraggingEnabled()) return true;
        /*YUNOS BEGIN*/
        //##module(homeshell)
        //##date:2013/12/06 ##author:jun.dongj@alibaba-inc.com##BugID:72676
        //downloading item in folder can be drag
        /*if(mLauncher.getModel().isDownloadStatus()) {
            ToastManager.makeToast(ToastManager.NOT_ALLOW_EDIT_IN_DOWNING);
            return true;
        }*/
        /*YUNOS END*/

        /*YUNOS BEGIN*/
        //##date:2014/7/8 ##author:zhangqiang.zq
        // aged mode
        if (HomeShellSetting.getFreezeValue(getContext())) {
            /*YUNOS BEGIN*/
            //##2015-03-16 BugID:5568655
            boolean toastShow = true;
            if(CheckVoiceCommandPressHelper.isPushTalkCanUse()) {
                Object object = v.getTag();
                if(object  instanceof ShortcutInfo) {
                    toastShow = !CheckVoiceCommandPressHelper.getInstance().isVoiceApp((ShortcutInfo) object);
                }
            }
            if(toastShow) {
                Toast.makeText(getContext(), R.string.aged_freeze_homeshell_toast, Toast.LENGTH_SHORT).show();
            }
            /*YUNOS END*/
            return true;
        }
        /*YUNOS END*/

        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }
            /* YUNOS BEGIN */
            // ##date:2014/06/03 ##author:yangshan.ys
            // batch operations to the icons in folder
            //prohibit the editfoldericon drag by longclick
            if(item.isEditFolderShortcut()) {
                return false;
            }
            /* YUNOS END */
          
            mLauncher.getWorkspace().onDragStartedWithItem(v);
            /*YUNOS BEGIN lxd */
            //mLauncher.getWorkspace().beginDragShared(v, this);
            CellLayout.CellInfo cellInfo = new CellLayout.CellInfo();
            cellInfo.cell = v;
            cellInfo.cellX = item.cellX;
            cellInfo.cellY = item.cellY;
            cellInfo.container = item.container;
            cellInfo.screen = item.screen;
            cellInfo.spanX = item.spanX;
            cellInfo.spanY = item.spanY;
            mLauncher.getWorkspace().startDrag(cellInfo, this);
            mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

            mCurrentDragInfo = item;
            mEmptyCell[0] = item.cellX;
            mEmptyCell[1] = item.cellY;
            mCurrentDragView = v;

            mContent.removeView(mCurrentDragView);
            mInfo.remove(mCurrentDragInfo);
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
        }
        return true;
    }

    public boolean isEditingName() {
        return mIsEditingName;
    }

    public void startEditingFolderName() {
        // mFolderName.setHint("");
        mIsEditingName = true;
    }

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }
    
    /*YUNOS BEGIN*/
    //##module(component name)
    //##date:2014/03/27 ##author:jun.dongj@alibaba-inc.com##BugID:105282
    //when folder is open, the title outline disappear, and when folder title is click,the title outline appear
    private void showFolderNameOutline(boolean show){
        if(show){
             mFolderName.setBackgroundResource(R.drawable.bg_folder_name);
        }else{
             mFolderName.setBackground(null);
             mFolderName.clearFocus();
        }
    }
    /*YUNOS END*/
    
    /*YUNOS BEGIN*/
    //##module(component name)
    //##date:2014/03/28 ##author:jun.dongj@alibaba-inc.com##BugID:105531
    //there is a cellayout outline when drag icon in folder, otherwise, hide it
    private void showDragOutline(boolean show){
        if(show){
            //when show drag outline ,first hide the name outline
            showFolderNameOutline(false);
            mFolderViewPager.setBackgroundResource(R.drawable.folder_drag_outline);
        }else{
            mFolderViewPager.setBackground(null);
        }
    }
    /*YUNOS END*/

    public void doneEditingFolderName(boolean commit) {
        // mFolderName.setHint(sHintText);
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String newTitle = mFolderName.getText().toString();

        /* YUNOS BEGIN */
        // ##date:2013/11/18 ##author:zhangqiang.zq
        // folder name can not be null
        if ((newTitle == null || newTitle.trim().equals(""))
                || (newTitle.length() > 0 && newTitle.charAt(0) == '#')) {
            /* YUNOS BEGIN */
            // ## date: 2016/06/20 ## author: yongxing.lyx
            // ## BugID:8431132:default folder auto change title when language
            // changed.
            if (newTitle.length() > 0 && newTitle.charAt(0) == '#') {
                Toast.makeText(getContext(), R.string.folder_name_error, Toast.LENGTH_LONG).show();
            }
            newTitle = mInfo.getDisplayTitle(getContext()).toString();
            /* YUNOS END */
            mFolderName.clearFocus();
            mFolderName.selectAll();
            // YUNOS BEGIN
            // ##date:2014/8/29 ##author:hongchao.ghc BUGID:5214614
        }
        /* YUNOS END */

        if (newTitle != null) {
            newTitle = newTitle.trim();
        }
        mFolderName.setText(newTitle);
        // YUNOS END
        String oldTitle = mInfo.title.toString();
        /* YUNOS BEGIN */
        // ## date: 2016/06/20 ## author: yongxing.lyx
        // ## BugID:8431132:default folder change title when language changed.
        if (!newTitle.contentEquals(getDisplayTitle(mLauncher))) {
            mInfo.setTitle(newTitle);
            LauncherModel.updateItemInDatabase(mLauncher, mInfo);
        }
        /* YUNOS END */

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }
        /* YUNOS BEGIN */
        // ##date:2013/12/02 ##author:xiaodong.lxd
        // for bug 69304
        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
/*        requestFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);*/
        /* YUNOS END */

        //BugID:5717551:userTrack for folder rename
        Map<String, String> param = new HashMap<String, String>();
        param.put("Before", oldTitle);
        param.put("After", newTitle);
        UserTrackerHelper.sendUserReport(UserTrackerMessage.MSG_RENAME_FOLDER, param);

        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            // YUNOS BEGIN
            // ##date:2014/09/16 ##author:hongchao.ghc ##BugID:5236250
            int start = mFolderName.getSelectionStart();
            int oldLength = mFolderName.getText().length();
            dismissEditingName();
            int length = mFolderName.getText().length();
            if (oldLength != length) {
                if (start == oldLength) {
                    start = length;
                } else {
                    start = 0;
                }
            }
            if (start < 0) {
                start = 0;
            }
            mFolderName.setSelection(start);
            // YUNOS END
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }

    public Drawable getDragDrawable() {
        return mIconDrawable;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
       mLauncher.closeFolder();
       return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    public FolderInfo getInfo() {
        return mInfo;
    }

    private class GridComparator implements Comparator<ShortcutInfo> {
        int mNumCols;
        public GridComparator(int numCols) {
            mNumCols = numCols;
        }

        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            int lhIndex = lhs.screen * getMaxItemsCountPerPage() + lhs.cellY * mNumCols + lhs.cellX;
            int rhIndex = rhs.screen * getMaxItemsCountPerPage() + rhs.cellY * mNumCols + rhs.cellX;
            return (lhIndex - rhIndex);
        }
    }

    private boolean placeInReadingOrder(ArrayList<ShortcutInfo> items) {
        int maxX = 0;
        int count = items.size();
        boolean isChanged = false;
        for (int i = 0; i < count; i++) {
            ShortcutInfo item = items.get(i);
            if (item.cellX > maxX) {
                maxX = item.cellX;
            }
        }

        GridComparator gridComparator = new GridComparator(maxX + 1);
        Collections.sort(items, gridComparator);
        final int countX = mContent.getCountX();
        final int maxItemsPerPage = getMaxItemsCountPerPage();
        for (int i = 0; i < count; i++) {
            int screen = i / maxItemsPerPage;
            int x = (i - screen * maxItemsPerPage) % countX;
            int y = (i - screen * maxItemsPerPage) / countX;
            ShortcutInfo item = items.get(i);
            if ((item.screen != screen) || (item.cellX != x) || (item.cellY != y)) {
                item.screen = screen;
                item.cellX = x;
                item.cellY = y;
                isChanged = true;
            }
        }
        return isChanged;
    }

    void bind(FolderInfo info) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;

        /* YUNOS BEGIN */
        // ##date:2013/12/02 ##author:zhangqiang.zq ##bugid: 75437
        if (children == null) {
            return;
        }
        /* YUNOS END */

        ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
        setupContentForNumItems(children.size());
        boolean isPosChanged = placeInReadingOrder(children);
        int count = 0;
        for (int i = 0; i < children.size(); i++) {
            ShortcutInfo child = (ShortcutInfo) children.get(i);
            if (!createAndAddShortcut(child)) {
                overflow.add(child);
            } else {
                count++;
            }
        }

        // We rearrange the items in case there are any empty gaps
        setupContentForNumItems(count);

        // If our folder has too many items we prune them from the list. This is an issue 
        // when upgrading from the old Folders implementation which could contain an unlimited
        // number of items.
        for (ShortcutInfo item: overflow) {
            mInfo.remove(item);
            LauncherModel.deleteItemFromDatabase(mLauncher, item);
        }

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        /* YUNOS BEGIN */
        // ## date: 2016/06/20 ## author: yongxing.lyx
        // ## BugID:8431132:default folder auto change title when language
        // changed.
        mFolderName.setText(getDisplayTitle(mLauncher));
        /* YUNOS END */
        //BugID:6078689:update items position only position changed
        if (isPosChanged == true
        /* YUNOS BEGIN */
        //## modules(Home Shell): [Category]
        //## date: 2015/07/30 ## author: wangye.wy
        //## BugID: 6221911: category on desk top
                && !mLauncher.isInLauncherCategoryMode()) {
        /* YUNOS END */
            updateItemLocationsInDatabase();
        }
    }

    /* YUNOS BEGIN */
    // ##date:2013/11/26 ##author:zhangqiang.zq
    // folder name
    void updateFolderName(CharSequence title) {
        mItemsInvalidated = true;
        updateTextViewFocus();

        mInfo.title = title;

        if (!sDefaultFolderName.contentEquals(title)) {
            mFolderName.setText(title);
        } else {
            mFolderName.setText(R.string.folder_hint_text);
        }

        LauncherModel.updateItemInDatabase(mLauncher, mInfo);
    }
    /* YUNOS END */

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param context The application's context.
     *
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) {
        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        setScaleX(0.8f);
        setScaleY(0.8f);
        setAlpha(0f);
        setState(STATE_SMALL);
    }

    public void animateOpen() {
        positionAndSizeAsIcon();
        if (!(getParent() instanceof DragLayer)) return;
        centerAboutIcon();
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
        final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
       
        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        String.format(getContext().getString(R.string.folder_opened),
                        mContent.getCountX(), mContent.getCountY()));
                mState = STATE_ANIMATING;
            }
            @Override
            public void onAnimationEnd(Animator animation) {
                mState = STATE_OPEN;
                setLayerType(LAYER_TYPE_NONE, null);
                
                setFocusOnFirstChild();
                setAlpha(1);
                setScaleX(1);
                setScaleY(1);
            }
        });
        oa.setDuration(mExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        oa.start();
    }

    public void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    public void setFocusOnFirstChild() {
        View firstChild = mContent.getChildAt(0, 0);
        if (firstChild != null) {
            firstChild.requestFocus();
        }
    }

    public void animateClosed() {
        if (!(getParent() instanceof DragLayer)) return;
        /* YUNOS BEGIN */
        // module(FolderAnimation)
        // ##date:2014/03/24 ##author:yaodi.yd ##BugID:104016
        // removed all old animation code to avoid animation conflict
        //PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
        //PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0.9f);
        //PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0.9f);
        //final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
        //oa.addListener(new AnimatorListenerAdapter() {
        //    @Override
        //    public void onAnimationEnd(Animator animation) {
        /* YUNOS END */
                onCloseComplete();
                setLayerType(LAYER_TYPE_NONE, null);
                mState = STATE_SMALL;
                /*YUNOS BEGIN*/
                // ##date:2014/3/10 ##author:yaodi.yd
                final Resources r = mLauncher.getResources();
                List<View> items = getItemsInReadingOrder();
                for (View item : items) {
                    item.setVisibility(View.VISIBLE);
                    item.setAlpha(1);
                    item.setScaleX(1);
                    item.setScaleY(1);
                }
                // added for BugID:102489
                final int height = LauncherApplication.getScreenHeight();
                final int width = LauncherApplication.getScreenWidth();
                mLauncher.getIndicatorView().setY((width > height ? width : height) - r.getDimensionPixelSize(R.dimen.page_indicator_workspace_marginbottom)  - r.getDimensionPixelSize(R.dimen.page_indicator_height));
                    mLauncher.getWorkspace().setVisibility(View.VISIBLE);
                    mLauncher.getWindow().getDecorView().setBackground(null);
    	        CellLayout hotseat = mLauncher.getHotseat().getLayout();
    	        ShortcutAndWidgetContainer hotseatContainer = hotseat.getShortcutAndWidgetContainer();
    	        int hotseatChildCount = hotseatContainer.getChildCount();
    	        for(int i=0;i<hotseatChildCount;i++) {
    	            View child = hotseatContainer.getChildAt(i);
                    if (child.getAlpha() < 1) { // Added for BugID:102954
                        child.setAlpha(1);
                        continue;
                    }
                    child.setY(0); // reset y to zero, it's original position
    	        }
                mLauncher.getWorkspace().setAllItemsOfCurrentPageVisibility(View.VISIBLE);
                /*YUNOS END*/
        /* YUNOS BEGIN */
        // module(FolderAnimation)
        // ##date:2014/03/24 ##author:yaodi.yd ##BugID:104016
        // removed all old animation code to avoid animation conflict
        //    }
        //    @Override
        //    public void onAnimationStart(Animator animation) {
        //        sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
        //                getContext().getString(R.string.folder_closed));
        //        mState = STATE_ANIMATING;
        //    }
        //});
        //oa.setDuration(mExpandDuration);
        //setLayerType(LAYER_TYPE_HARDWARE, null);
        //oa.start();
        /* YUNOS END */
    }

    /* YUNOS BEGIN */
    // ##date:2014/9/25 ##author:yangshan.ys BugId:5255762
    public void onThemeChanged() {
        // recreate all the children and updateLayout if the theme change)
        for (CellLayout mContent : mContentList) {
            mContent.removeAllViewsInLayout();
        }
        mItemsInReadingOrder.clear();
        updateFolderLayout(isSupportCardIcon());
        bind(mInfo);
    }
    /* YUNOS END */

    public boolean acceptDrop(DragObject d) {
        final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        
        boolean folderAcceptDrop = ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT ||
                itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT_DOWNLOADING
                //BugID:92481:need confirm what is acceptDrop
      // remove vp install
      /*        || itemType == LauncherSettings.Favorites.ITEM_TYPE_VPINSTALL*/) &&
                !isFull());
        if (folderAcceptDrop) {
            if (mState == STATE_OPEN) {
                ShortcutAndWidgetContainer container = mContent.getShortcutAndWidgetContainer();
                if (container.getChildCount() == 1) {
                    View v = container.getChildAt(0);
                    ShortcutInfo editIconInfo = mInfo.getmEditFolderShortcutInfo();
                    if (v != null && v.getTag() == editIconInfo && editIconInfo.cellX == 0 && editIconInfo.cellY == 0) {
                        folderAcceptDrop = false;
                        if (d.dragView != null) {
                            d.dragView.remove();
                            d.dragView = null;
                        }
                    }
                }
            }
        }
        Log.d(TAG, "sxsexe--------->acceptDrop folderAcceptDrop " + folderAcceptDrop);
        return folderAcceptDrop;
    }

    protected boolean findAndSetEmptyCells(ShortcutInfo item) {
        int[] emptyCell = new int[2];
        int screen = 0;
        for (screen = 0; screen < mContentList.size(); screen++) {
            if (mContentList.get(screen).findCellForSpan(emptyCell, item.spanX, item.spanY)) {
                item.screen = screen;
                item.cellX = emptyCell[0];
                item.cellY = emptyCell[1];
                return true;
            }
        }
            return false;
    }

    protected boolean createAndAddShortcut(ShortcutInfo item) {
        final BubbleTextView textView =
                (BubbleTextView) mInflater.inflate(R.layout.application, this, false);
            BubbleController.applyToView(item, textView);
            //in the function "applyFromShortcutInfo", the text has been alread set by BubbleTextView.setTitle
            //textView.setText(item.title); 
            textView.setTag(item);
            BubbleController.updateView(textView);

            textView.setOnClickListener(this);
            textView.setOnLongClickListener(this);

            // We need to check here to verify that the given item's location isn't already occupied
            // by another item.
        if (item.screen >= mContentList.size()
                || mContentList.get(item.screen).getChildAt(item.cellX, item.cellY) != null
                || item.cellX < 0 || item.cellY < 0
                || item.cellX >= mContentList.get(item.screen).getCountX()
                || item.cellY >= mContentList.get(item.screen).getCountY()) {
                // This shouldn't happen, log it. 
            Log.e(TAG,
                    "Folder order not properly persisted during bind,the item is" + item.toString());
                if (!findAndSetEmptyCells(item)) {
                    return false;
                }
            }

        CellLayout.LayoutParams lp = new CellLayout.LayoutParams(item.cellX, item.cellY,
                item.spanX, item.spanY);
        boolean insert = false;
        textView.setOnKeyListener(new FolderKeyEventListener());
        textView.setHapticFeedbackEnabled(false);
        mContentList.get(item.screen).addViewToCellLayout(textView, insert ? 0 : -1, (int) item.id,
                lp, true);
            return true;
    }

    public void onDragEnter(DragObject d) {
        if (mState == Folder.STATE_ANIMATING) {
            return;
        }
        /*YUNOS BEGIN*/
        //##module(component name)
        //##date:2014/03/28 ##author:jun.dongj@alibaba-inc.com##BugID:105531
        //there is a cellayout outline when drag icon in folder, otherwise, hide it
        showDragOutline(true);
        /*YUNOS END*/
        mPreviousTargetCell[0] = -1;
        mPreviousTargetCell[1] = -1;
        mOnExitAlarm.cancelAlarm();
        /* YUNOS BEGIN */
        // ##date:2015/1/30 ##author:zhanggong.zg ##BugID:5744899
        // Enables dragging icon out of folder through left and right edge.
        mDraggingToLeftEdge = false;
        mDraggingToRightEdge = false;
        mDragExit = false;
        /* YUNOS END */
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            try {
                cancelMoveAnimation();
                realTimeReorder(mEmptyCell, mTargetCell);
            } catch (Exception e) {
                Log.e(TAG, "reorder error", e);
            }
        }
    };

    boolean readingOrderGreaterThan(int[] v1, int[] v2) {
        if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
            return true;
        } else {
            return false;
        }
    }

    private void realTimeReorder(int[] empty, int[] target) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int delay = 0;
        float delayAmount = 30;
        if (readingOrderGreaterThan(target, empty)) {
            wrap = empty[0] >= mContent.getCountX() - 1;
            startY = wrap ? empty[1] + 1 : empty[1];
            for (int y = startY; y <= target[1]; y++) {
                startX = y == empty[1] ? empty[0] + 1 : 0;
                endX = y < target[1] ? mContent.getCountX() - 1 : target[0];
                for (int x = startX; x <= endX; x++) {
                    View v = mContent.getChildAt(x,y);
                    if (isEditIcon(v)) {
                        continue;
                    }
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        } else {
            wrap = empty[0] == 0;
            startY = wrap ? empty[1] - 1 : empty[1];
            for (int y = startY; y >= target[1]; y--) {
                startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX() - 1;
                endX = y > target[1] ? 0 : target[0];
                for (int x = startX; x >= endX; x--) {
                    View v = mContent.getChildAt(x,y);
                    if (isEditIcon(v)) {
                        continue;
                    }
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        }
    }

    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }

    public void onDragOver(DragObject d) {
        if (mState == Folder.STATE_ANIMATING) {
            return;
        }
        if (mScrolling)
            return;
        float[] r = getDragViewVisualCenter(d.x, d.y - getFolderNamePadding(), d.xOffset, d.yOffset, d.dragView, null);
        mTargetCell = mContent.findNearestArea((int) r[0], (int) r[1], 1, 1, mTargetCell);

        if (isLayoutRtl()) {
            mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
        }

        if (mTargetCell[0] != mPreviousTargetCell[0] || mTargetCell[1] != mPreviousTargetCell[1]) {
            mReorderAlarm.cancelAlarm();
            mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
            mReorderAlarm.setAlarm(150);
            mPreviousTargetCell[0] = mTargetCell[0];
            mPreviousTargetCell[1] = mTargetCell[1];
        }
        /* YUNOS BEGIN */
        // ##date:2015/1/30 ##author:zhanggong.zg ##BugID:5744899
        // Enables dragging icon out of folder through left and right edge.
        mDraggingToLeftEdge = false;
        mDraggingToRightEdge = false;
        /* YUNOS END */
    }

    // This is used to compute the visual center of the dragView. The idea is that
    // the visual center represents the user's interpretation of where the item is, and hence
    // is the appropriate point to use when determining drop location.
    private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
            DragView dragView, float[] recycle) {
        float res[];
        if (recycle == null) {
            res = new float[2];
        } else {
            res = recycle;
        }

        // These represent the visual top and left of drag view if a dragRect was provided.
        // If a dragRect was not provided, then they correspond to the actual view left and
        // top, as the dragRect is in that case taken to be the entire dragView.
        // R.dimen.dragViewOffsetY.
        int left = x - xOffset;
        int top = y - yOffset;

        // In order to find the visual center, we shift by half the dragRect
        res[0] = left + dragView.getDragRegion().width() / 2;
        res[1] = top + dragView.getDragRegion().height() / 2;

        return res;
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

    public void completeDragExit() {
        /* YUNOS BEGIN */
        // ##date:2014/3/13 ##author:zhangqiang.zq
        // BugID:100197
        setupContentForNumItems(getItemCount());
        /* YUNOS END */

        /* YUNOS BEGIN */
        //## modules(Home Shell): [Folder]
        //## date: 2014/03/10 ## author: yaodi.yd
        //## date: 2015/12/15 ## author: wangye.wy
        //## BugID: 6436685: use function instead of without expand animation
        mLauncher.closeFolder();
        //mLauncher.closeFolderWithoutExpandAnimation();
        /* YUNOS END */
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mRearrangeOnClose = true;
    }

    public void onDragExit(DragObject d) {
        if (mState == Folder.STATE_ANIMATING) {
            return;
        }
        // We only close the folder if this is a true drag exit, ie. not because a drop
        // has occurred above the folder.
        if (!d.dragComplete) {
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
        }
        cancelMoveAnimation();
        mReorderAlarm.cancelAlarm();
        mDragExit = true;
    }

    public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
            boolean success) {
        //mDropAccepted = success;
        Log.d(TAG, "sxsexe---------> onDropCompleted dragInfo " + d.dragInfo 
                + " success " + success
                + " mDeleteFolderOnDropCompleted " + mDeleteFolderOnDropCompleted
                + " mItemAddedBackToSelfViaIcon " + mItemAddedBackToSelfViaIcon
                + " item count " + getItemCount()
                + " mHasDirtyData " + mHasDirtyData);
        /*YUNOS BEGIN*/
        //##module(component name)
        //##date:2014/03/28 ##author:jun.dongj@alibaba-inc.com##BugID:105531
        //there is a cellayout outline when drag icon in folder, otherwise, hide it
        showDragOutline(false);
        /*YUNOS END*/
        mShortcutInfoCache = (ShortcutInfo)d.dragInfo;
        mLauncher.setCurrentFolder(this);
        if (success) {
            if(target instanceof DeleteDropTarget && mShortcutInfoCache.itemType == Favorites.ITEM_TYPE_APPLICATION) {
                //go to uninstall or remove, 
                Log.d(TAG, "sxsexe---------> onDropCompleted do not need to replaceFolderWithFinalItem");
                mHasDirtyData = true;
                /*YUNOS BEGIN*/
                //##date:2014/01/18 ##author:hao.liuhaolh ##BugID:83464
                //app icon remove issue in folder
                if ((mShortcutInfoCache.intent != null) &&
                     (mShortcutInfoCache.intent.getComponent() !=null) &&
                     (mShortcutInfoCache.intent.getComponent().getPackageName() != null)) {
                    boolean storgeMount = Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);

                    String packageName = mShortcutInfoCache.intent.getComponent().getPackageName();
                    final PackageManager packageManager = ((Context)mLauncher).getPackageManager();

                    final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
                    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
                    mainIntent.setPackage(packageName);
                    final List<ResolveInfo> apps = packageManager.queryIntentActivities(mainIntent, 0);
                    if((apps == null || apps.size() == 0)&&(storgeMount == true)) {
                        Log.d(TAG, "sxsexe------->no app info, so it need to be cleaned");
                        mHasDirtyData = false;
                    }
               }
               /*YUNOS END*/
            }
            /*YUNOS BEGIN*/
            //##date:2014/7/2 ##author:yangshan.ys##BugID:134407
            //if the target is workspace or hotseat when drag or fling icon ,call this method
            mDeleteFolderOnDropCompleted =  mInfo.count() <= 1;
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon && !(target instanceof DeleteDropTarget)) {
            /*YUNOS END*/
                if(!mHasDirtyData) {
                    //drag to workspace or hotseat
                    replaceFolderWithFinalItem();
                    this.setNeedReplaceFolderWithFinalItemFlase();
                }
            }
            //xiaodong.lxd 2015-01-16  BugID:5235465
            if(!mDeleteFolderOnDropCompleted && (target != this) && !(target instanceof DeleteDropTarget)) {
                ShortcutInfo item;
                if (d.dragInfo instanceof ApplicationInfo) {
                    item = ((ApplicationInfo) d.dragInfo).makeShortcut();
                } else {
                    item = (ShortcutInfo) d.dragInfo;
                }
                updateFolderNameWithRemainedApp(item);
            }
            //end 5235465
        } else {
            Log.d(TAG, "sxsexe---------> onDropCompleted drag failed need to get the item back " );
            // The drag failed, we need to return the item to the folder
            mFolderIcon.onDrop(d);

            // We're going to trigger a "closeFolder" which may occur before this item has
            // been added back to the folder -- this could cause the folder to be deleted
            if (mOnExitAlarm.alarmPending()) {
                mSuppressFolderDeletion = true;
            }
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                completeDragExit();
            }
        }
        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mDragExit = false;

        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabase();
        mLauncher.getWorkspace().cleanDragInfoFromFolder();
        mLauncher.getWorkspace().checkAndRemoveEmptyCell();
    }

    @Override
    public boolean supportsFlingToDelete() {
        return true;
    }

    public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
        // Do nothing
    }

    @Override
    public void onFlingToDeleteCompleted() {
        // Do nothing
    }

    private void updateItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            /* YUNOS BEGIN */
            // ##date:2014/07/04 ##author:yangshan.ys##BugID:135044
            // prevent the editfoldericon writting to database
            if (info.itemFlags != Favorites.ITEM_FLAGS_EDIT_FOLDER) {
                LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, info.screen,
                        info.cellX, info.cellY);
            }
            /* YUNOS END */
        }
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return true;
    }

    public DropTarget getDropTargetDelegate(DragObject d) {
        return null;
    }

    private void setupContentDimensions(int count) {
        if (count <= 0) {
            return;
        }
        ArrayList<View> list = getItemsInReadingOrder(mState == STATE_OPEN);
        // the view amount in folder and the shortcutinfo amount in folder may
        // diff when onDrop
        if (list.size() != count) {
            count = Math.max(list.size(), count);
        }
        /* YUNOS BEGIN */
        // ##date:2013/11/25 ##author:zhangqiang.zq
        // modify fold display style
        /*
         * int countX = mContent.getCountX();
         * int countY = mContent.getCountY();
         * boolean done = false;
         * while (!done) { int oldCountX = countX; int oldCountY = countY; if
         * (countX * countY < count) { // Current grid is too small, expand it
         * if ((countX <= countY || countY == mMaxCountY) && countX <
         * mMaxCountX) { countX++; } else if (countY < mMaxCountY) { countY++; }
         * if (countY == 0) countY++; } else if ((countY - 1) * countX >= count
         * && countY >= countX) { countY = Math.max(0, countY - 1); } else if
         * ((countX - 1) * countY >= count) { countX = Math.max(0, countX - 1);
         * } done = countX == oldCountX && countY == oldCountY; }
         */

        for (CellLayout mContent : mContentList) {
            mContent.removeAllViews();
        }
        /* YUNOS BEGIN */
        // ##date:2014/9/25 ##author:yangshan.ys BugId:5255762
        int pageCount = count / getMaxItemsCountPerPage()
                + ((count % getMaxItemsCountPerPage() == 0) ? 0 : 1);
        int maxPage = MAX_ITEMS_COUNT / getMaxItemsCountPerPage();
        if (pageCount > maxPage) {
            pageCount = maxPage;
        }
        adjustContentListSize(pageCount);
        mMaxCountY = ConfigManager.getFolderMaxCountY();
        for (int page = pageCount - 1; page >= 0; page--) {
            mContentList.get(page).setGridSize(mMaxCountX, mMaxCountY);
        }
        /* YUNOS END */
        /* YUNOS END */
        arrangeChildren(list);
    }

    public boolean isFull() {
        return getItemCount() >= MAX_ITEMS_COUNT;
    }

    @Deprecated
    private void centerAboutIcon() {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

        int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
        int height = getPaddingTop() + getPaddingBottom() + mContent.getDesiredHeight()
                + mFolderNameHeight + mFolderNameContentGap;
        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);

        //float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);

        //int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
        //int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
        //int centeredLeft = centerX - width / 2;
        //int centeredTop = centerY - height / 2;

        int currentPage = mLauncher.getWorkspace().getCurrentPage();
        // In case the workspace is scrolling, we need to use the final scroll to compute
        // the folders bounds.
        // We first fetch the currently visible CellLayoutChildren
        CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace().getChildAt(currentPage);
        if (currentLayout != null) {
            mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
            ShortcutAndWidgetContainer boundingLayout = currentLayout
                    .getShortcutAndWidgetContainer();
            Rect bounds = new Rect();
            parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
            // We reset the workspaces scroll
            mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);
        }
        //added by dongjun for folder in screen center begin
//        // We need to bound the folder to the currently visible CellLayoutChildren
//        int left = Math.min(Math.max(bounds.left, centeredLeft),
//                bounds.left + bounds.width() - width);
//        int top = Math.min(Math.max(bounds.top, centeredTop),
//                bounds.top + bounds.height() - height);
//        // If the folder doesn't fit within the bounds, center it about the desired bounds
//        if (width >= bounds.width()) {
//            left = bounds.left + (bounds.width() - width) / 2;
//        }
//        if (height >= bounds.height()) {
//            top = bounds.top + (bounds.height() - height) / 2;
//        }
//        
//        /* YUNOS BEGIN */
//        // ##date:2013/11/27 ##author:zhangqiang.zq
//        // edit text hide by inputMothod
//        int parentHeight = parent.getWidth();
//        if (top > parentHeight / 2) {
//            top = parentHeight / 2;
//        }
//        /* YUNOS END */
//
//        int folderPivotX = width / 2 + (centeredLeft - left);
//        int folderPivotY = height / 2 + (centeredTop - top);
//        setPivotX(folderPivotX);
//        setPivotY(folderPivotY);
//        mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() *
//                (1.0f * folderPivotX / width));
//        mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() *
//                (1.0f * folderPivotY / height));

        lp.width = width;
        lp.height = height;
        
        int screenwidth = LauncherApplication.getScreenWidth();
        int screenheight = LauncherApplication.getScreenHeight();
        /* YUNOS BEGIN */
        // ##date:2014/03/20 ##author:yaodi.yd ##BugID:102489
//        lp.x = (screenwidth-width)/2;
//        lp.y = (screenheight-height)/2;
        lp.x = ((screenwidth > screenheight ? screenheight : screenwidth)-width)/2;
        lp.y = ((screenwidth > screenheight ? screenwidth : screenheight)-height)/2;
        /* YUNOS END */
//        lp.x = getPaddingLeft();
//        lp.y = getPaddingTop();
//        lp.width = screenwidth - getPaddingLeft() - getPaddingRight();
//        lp.height = screenheight - getPaddingTop() - getPaddingBottom();
        //added by dongjun for folder in screen center end
    }

    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    private void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        //centerAboutIcon();
    }

    private int mPageIndicatorHeight = getResources().getDimensionPixelSize(
            R.dimen.page_indicator_height);
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        View parent = mLauncher.getDragLayer();
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        int contentWidth = mContentWidth;
        int contentHeight = mContentHeight;
        int width = getPaddingLeft() + getPaddingRight() + contentWidth;
        int height = getPaddingTop() + getPaddingBottom() + contentHeight
                + mFolderNameHeight + mFolderNameContentGap + mPageIndicatorHeight;
        lp.width = width;
        lp.height = height;
        lp.x = (parent.getWidth() - width) / 2;
        lp.y = (parent.getHeight() - height) / 2;

        int contentWidthSpec = MeasureSpec.makeMeasureSpec(contentWidth,
                MeasureSpec.EXACTLY);
        int contentHeightSpec = MeasureSpec.makeMeasureSpec(contentHeight,
                MeasureSpec.EXACTLY);
        mFolderViewPager.measure(contentWidthSpec, contentHeightSpec);

        contentWidthSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.AT_MOST);
        contentHeightSpec = MeasureSpec.makeMeasureSpec(mPageIndicatorHeight, MeasureSpec.AT_MOST);
        mPageIndicator.measure(contentWidthSpec, contentHeightSpec);
        int titleWidthSpec = MeasureSpec.makeMeasureSpec(width,
                MeasureSpec.AT_MOST);
        int titleHeightSpec = MeasureSpec.makeMeasureSpec(mFolderNameHeight,
                MeasureSpec.EXACTLY);
        mFolderName.measure(titleWidthSpec, titleHeightSpec);
        setMeasuredDimension(width, height);
    }

    private void arrangeChildren(ArrayList<View> list) {
        int[] vacant = new int[2];
        if (list == null) {
            list = getItemsInReadingOrder(mState == STATE_OPEN);
        }
        for (CellLayout mContent : mContentList) {
            mContent.removeAllViews();
        }
        int pageCount = 0;
        CellLayout mContent = mContentList.get(pageCount);
        for (int i = 0; i < list.size(); i++) {
            if (i > 0 && i % getMaxItemsCountPerPage() == 0) {
                pageCount++;
                mContent = mContentList.get(pageCount);
            }
            View v = list.get(i);
            mContent.getVacantCell(vacant, 1, 1);
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
            lp.cellX = vacant[0];
            lp.cellY = vacant[1];
            ItemInfo info = (ItemInfo) v.getTag();
            if (info.screen != pageCount || info.cellX != vacant[0] || info.cellY != vacant[1]) {
                info.screen = pageCount;
                info.cellX = vacant[0];
                info.cellY = vacant[1];
                LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, pageCount,
                        info.cellX, info.cellY);
            }
            boolean insert = false;
            mContent.addViewToCellLayout(v, insert ? 0 : -1, (int)info.id, lp, true);
        }
        mItemsInvalidated = true;
    }

    public int getItemCount() {
        int count = 0;
        for (CellLayout mContent : mContentList) {
            count += mContent.getShortcutAndWidgetContainer().getChildCount();
        }
        return count;
    }

    public View getItemAt(int index) {
        int calcIndex  = index / getMaxItemsCountPerPage();
        //BugID:5699788:IndexOutOfBoundsException in Folder getItemAt
        if (calcIndex >= mContentList.size()) {
            //error status, retrun the last item in ContentList
            if (mContentList.size() <= 0) {
                return null;
            }
            ShortcutAndWidgetContainer container = mContentList.get(mContentList.size() - 1).getShortcutAndWidgetContainer();
            if (container.getChildCount() <= 0) {
                return null;
            }
            int lastChildIndex = container.getChildCount() - 1;
            return container.getChildAt(lastChildIndex);
        } else {
            return mContentList.get(calcIndex).getShortcutAndWidgetContainer()
                    .getChildAt(index % getMaxItemsCountPerPage());
        }
    }

    public CellLayout getPageAt(int index) {
        return mContentList.get(index);
    }

    public int getCurrentPageIndex() {
        return mFolderViewPager.getCurrentItem();
    }

    public CellLayout getCurrentPage() {
        return mContentList.get(mFolderViewPager.getCurrentItem());
    }

    public PageIndicatorView getIndicatorView() {
        return mPageIndicator;
    }

    public void onCloseComplete() {
        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
        }
        mDragController.removeDropTarget((DropTarget) this);
        //YUNOS clear onDrop animation before close folder @kerong.skr
        mLauncher.getDragLayer().clearAnimatedView();
        clearFocus();
        mFolderIcon.requestFocus();

        if (mRearrangeOnClose  && mLauncher.checkFolderIdValid(mInfo.id)) {
        	    //YUNOS lxd : if the folder has been removed, no need to arrange
            setupContentForNumItems(getItemCount());
            mRearrangeOnClose = false;
        }
        
        if (getItemCount() <= 1) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                //canceled by xiaodong.lxd
                //replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
    }

    /* YUNOS BEGIN */
	// ##date:2014/03/06 ##author:yaodi.yd
    private boolean mNeedReplaceFolderWithFinalItem;
    public boolean getNeedReplaceFolderWithFinalItem() {
    	return mNeedReplaceFolderWithFinalItem;
    }
    public void setNeedReplaceFolderWithFinalItemFlase() {
    	this.mNeedReplaceFolderWithFinalItem = false;
    }
    /* YUNOS END */

    public void replaceFolderWithFinalItem() {
		Log.i(TAG, "replaceFolderWithFinalItem");
        replaceFolderWithFinalItem(true);
    }

    public void replaceFolderWithFinalItem(boolean animated) {
		Log.i(TAG, "replaceFolderWithFinalItem animated="+animated);
        /* YUNOS BEGIN */
    	// ##date:2014/03/06 ##author:yaodi.yd
        if (mLauncher.getWorkspace().isPlayingAnimation()) {
        	mNeedReplaceFolderWithFinalItem = true;
    	    return;
        }
        /* YUNOS END */
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                /* YUNOS BEGIN */
            	// ##date:2014/03/06 ##author:yaodi.yd
                if (mLauncher.getWorkspace().isPlayingAnimation()) {
                	mNeedReplaceFolderWithFinalItem = true;
            	    return;
                }
                /* YUNOS END */
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screen);

               View child = null;
                // Move the item from the folder to the workspace, in the position of the folder
                /* YUNOS BEGIN */
                // ##date:2015-1-22 ##author:zhanggong.zg ##BugID:5730858
                // mInfo.contents can be already cleared by LauncherModel.checkFolderAndUpdate()
                if (getItemCount() == 1 && !mInfo.contents.isEmpty()) {
                /* YUNOS END */
                    ShortcutInfo finalItem = mInfo.contents.get(0);
                    child = mLauncher.createShortcut(R.layout.application, cellLayout,
                            finalItem);
                    if (ConfigManager.isLandOrienSupport()) {
                        finalItem.cellX = mInfo.cellX;
                        finalItem.cellY = mInfo.cellY;
                        finalItem.cellXPort = mInfo.cellXPort;
                        finalItem.cellYPort = mInfo.cellYPort;
                        finalItem.cellXLand = mInfo.cellXLand;
                        finalItem.cellYLand = mInfo.cellYLand;
                    }
                    LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                            mInfo.screen, mInfo.cellX, mInfo.cellY);
                }
                if (getItemCount() <= 1 &&
                    LauncherApplication.getLauncher() != null &&
                    !LauncherApplication.getLauncher().isInLauncherCategoryMode()&&
                    !LauncherApplication.getLauncher().getModel().isInProcess()) {
                    // Remove the folder
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    if (cellLayout != null) {
                        cellLayout.removeView(mFolderIcon);
                    }
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                }
                // We add the child after removing the folder to prevent both from existing at
                // the same time in the CellLayout.
                if (child != null) {
                    if(mInfo.container == Favorites.CONTAINER_HOTSEAT) {
                        /* YUNOS BEGIN */
                        // ##date:2013/12/09 ##author:xiaodong.lxd
                        // replace folder with the last item in hotseat
                        int index = mInfo.screen;
                        mLauncher.getHotseat().onDrop(true,-1,  null, child, true);
                        mLauncher.getWorkspace().addInHotseat(child, mInfo.container, index,
                                index, 0, mInfo.spanX, mInfo.spanY, index);
                        /* YUNOS END */
                    } else {
                        mLauncher.getWorkspace().addInScreen(child, mInfo.container, mInfo.screen,
                                mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
                        if (ConfigManager.isLandOrienSupport()) {
                            LauncherModel.markCellsOccupiedInNonCurrent(mInfo, true);
                        }
                    }
                }

                /* YUNOS BEGIN */
                // ##date:2013/12/04 ##author:zhangqiang.zq
                // bug id:69310
                LauncherAnimUtils.clearDeadAnimation();
                /* YUNOS END */
            }
        };
        View finalChild = getItemAt(0);
        if (finalChild != null) {
            /* YUNOS BEGIN */
            // ##date:2014/10/9 ##author:zhanggong.zg ##BugID:5321602
            if (animated) {
                mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
            } else {
                onCompleteRunnable.run();
            }
            /* YUNOS END */
        }
        /*YUNOS BEGIN*/
        //##date:2014/02/28 ##author:hao.liuhaolh ##BugID:95951
        //folder that only one item in it
        else if (getItemCount() == 0) {
            //in some abnormal case, only one item in folder
            //and the item is moved out of folder, in this case
            //the empty folder need to be deleted
            Log.d(TAG, "only one item in folder and the item is moved out of folder");
            CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screen);
            cellLayout.removeView(mFolderIcon);
            if (mFolderIcon instanceof DropTarget) {
                mDragController.removeDropTarget((DropTarget) mFolderIcon);
            }
            mLauncher.removeFolder(mInfo);
            LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
        }
        /*YUNOS END*/
        mDestroyed = true;
        mHasDirtyData = false;
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    private void updateTextViewFocus() {
        View lastChild = getItemAt(getItemCount() - 1);
        if (lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
        }
    }

    void cancelMoveAnimation() {
        if (moveAnim != null && moveAnim.isStarted()) {
            moveAnim.cancel();
        }
    }

    public void onDrop(DragObject d) {
        mDragExit = false;
        cancelMoveAnimation();
        mReorderAlarm.cancelAlarm();
        /* YUNOS BEGIN */
        // ##date:2014/1/13 ##author:zhangqiang.zq
        // 85715
        //mLauncher.exitFullScreen();
        /* YUNOS END */
        ShortcutInfo item;
        if (d.dragInfo instanceof ApplicationInfo) {
            // Came from all apps -- make a copy
            item = ((ApplicationInfo) d.dragInfo).makeShortcut();
            item.spanX = 1;
            item.spanY = 1;
        } else {
            item = (ShortcutInfo) d.dragInfo;
        }
        // Dragged from self onto self, currently this is the only path possible, however
        // we keep this as a distinct code path.
        if (item == mCurrentDragInfo) {
            ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView.getLayoutParams();
            si.cellX = lp.cellX = mEmptyCell[0];
            si.cellX = lp.cellY = mEmptyCell[1];
            String title = si.title.toString();
            if(mCurrentDragView.getParent() != null) {
                ((ViewGroup)mCurrentDragView.getParent()).removeView(mCurrentDragView);
                Log.e(TAG, "The icon whose name is :" + title
                        + " has already have the parent when onDrop,remove it to avoid crash");
            }
            mContent.addViewToCellLayout(mCurrentDragView, -1, (int)item.id, lp, true);
            if (d.dragView.hasDrawn()) {
                mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, mCurrentDragView);
            } else {
                d.deferDragViewCleanupPostAnimation = false;
                mCurrentDragView.setVisibility(VISIBLE);
            }
            mItemsInvalidated = true;
            setupContentDimensions(getItemCount());
            mSuppressOnAdd = true;
        } else {
            d.deferDragViewCleanupPostAnimation = false;
        }
        mInfo.add(item);
    }

    /* YUNOS BEGIN */
    // ##date:2014/1/13 ##author:zhangqiang.zq
    // BugID: 102038
    // YUNOS BEGIN
    // ##date:2014/09/16 ##author:hongchao.ghc ##BugID:5236424
    public void hideSoftInputMethod(Activity activity) {
        View v;
        if (activity == null || activity.getWindow() == null) {
            v = mFolderName;
        } else {
            v = activity.getWindow().peekDecorView();
        }
        // YUNOS END
        try {
            if (v != null && v.getWindowToken() != null) {
                InputMethodManager imm = (InputMethodManager) getContext()
                        .getSystemService(Context.INPUT_METHOD_SERVICE);
                boolean result = imm
                        .hideSoftInputFromWindow(v.getWindowToken(), 0);
                Log.d(TAG, "hideSoftInputMethod, ret:" + result);
            }
        } catch (RuntimeException e) {
            // add try catch block due to InputMethod throws
            // RuntimeException;
            // BugID:101639
            Log.e(TAG, e.toString(), e);
        }
    }
    /* YUNOS END */

    public void onAdd(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        /* YUNOS BEGIN */
        // ##date:2013/12/03 ##author:xiaodong.lxd
        // bug id:69270
        mHasDirtyData = false;
        mDestroyed = false;
        /* YUNOS END */
        
        if (mSuppressOnAdd) return;

        /* YUNOS BEGIN */
        // ## date: 2016/06/20 ## author: yongxing.lyx
        // ## BugID:8410714:edit icon position error after clone.
        boolean forceInsert = false;
        if (mInfo.isEditFolderInContents() && !item.isEditFolderShortcut()) {
            int xCount = mContent.getCountX();
            int yCount = mContent.getCountY();
            ShortcutInfo editItem = mInfo.getmEditFolderShortcutInfo();
            if ((item.screen * xCount * yCount + xCount * item.cellY + item.cellX) >= (editItem.screen
                    * xCount * yCount + xCount * editItem.cellY + editItem.cellX)) {
                Log.w(TAG, "onAdd() has editFolderShortcut, insert to s:" + editItem.screen + " x:"
                        + editItem.cellX + " y:" + editItem.cellY + ", item:" + item);
                mInfo.dumpContent("onAdd");
                item.screen = editItem.screen;
                item.cellX = editItem.cellX;
                item.cellY = editItem.cellY;
                forceInsert = true;
            }
        }
        /* YUNOS BEGIN */

        /* YUNOS BEGIN */
        // ##date:2013/11/28 ##author:zhangqiang.zq
        // bug id:66131
        if ((item.container >= 0 && item.cellX >= 0 && item.cellY >= 0) || forceInsert) {
            insertItem(item);
            return;
        }
        /* YUNOS END */
        if (!findAndSetEmptyCells(item)) {
            // The current layout is full, can we expand it?
            setupContentForNumItems(getItemCount() + 1);
            findAndSetEmptyCells(item);
        }
        
        final long originalContainer = item.container;
        createAndAddShortcut(item);
        LauncherModel.addOrMoveItemInDatabase(
                mLauncher, item, mInfo.id, item.screen, item.cellX, item.cellY);
        
        /*YUNOS BEGIN added by xiaodong.lxd : when add EditFolderIcon, need to run replaceFolderWithFinalItem*/
        if(item.isEditFolderShortcut()) {
        	mNeedReplaceFolderWithFinalItem = true;
        }
        /*YUNOS END*/

        /* YUNOS BEGIN */
        // ##date:2014/9/29 ##author:zhanggong.zg ##BugID:5244146
        // Hideseat callback: drag icon from hide-seat to folder
        if (originalContainer == LauncherSettings.Favorites.CONTAINER_HIDESEAT) {
            Hideseat hideseat = mLauncher.getHideseat();
            if (hideseat != null && !hideseat.isDraggingIconToFolder()) {
                // try to find corresponding view for the item
                View iconView = getViewForInfo(item);
                hideseat.onDragIconFromHideseatToFolder(iconView, item, this);
            }
        }
        /* YUNOS END */
    }

    /* YUNOS BEGIN */
    // ##date:2013/11/28 ##author:zhangqiang.zq
    // bug id:66131
    private void insertItem(ShortcutInfo item) {
        // TODO Auto-generated method stub
        setupContentForNumItems(getItemCount() + 1);
        int xCount = mContent.getCountX();
        int yCount = mContent.getCountY();
        int currentPos = item.screen * xCount * yCount + item.cellY * xCount + item.cellX;
        int maxItemsPerPage = getMaxItemsCountPerPage();
        Collections.sort(mInfo.contents, infoDownComp);
        mInfo.contents.remove(item);
        mInfo.contents.add(item);
        for (ShortcutInfo si : mInfo.contents) {
            int pos = si.screen * xCount * yCount + si.cellY * xCount + si.cellX;
            if (si == item) {
                createAndAddShortcut(si);
                LauncherModel.addOrMoveItemInDatabase(mLauncher, si, mInfo.id, si.screen, si.cellX,
                        si.cellY);
                continue;
            }
            if (pos >= currentPos || (pos == currentPos && !item.equals(si))) {
                View view = mContentList.get(si.screen).getChildAt(si.cellX, si.cellY);
                mContentList.get(si.screen).removeView(view);
                si.screen = (pos + 1) / maxItemsPerPage;
                si.cellX = ((pos + 1) % maxItemsPerPage) % xCount;
                si.cellY = ((pos + 1) % maxItemsPerPage) / xCount;
                if (view == null || mContentList.size() <= si.screen) {
                    Log.e(TAG, "the view of " + si.title + "should not be null,but now is null");
                    createAndAddShortcut(si);
                } else if (view.getTag() == null || view.getTag() != si) {
                    String title = view.getTag() == null ? "DefaultName"
                            : ((ShortcutInfo) view.getTag()).title.toString();
                    Log.e(TAG, "The shortcutInfo:" + item.title
                            + " is different with the shortcut associated with view:" + title);
                } else {
                    CellLayout.LayoutParams lp = new CellLayout.LayoutParams(si.cellX, si.cellY,
                            si.spanX, si.spanY);
                    boolean insert = false;
                    mContentList.get(si.screen).addViewToCellLayout(view, insert ? 0 : -1,
                            (int) si.id, lp, true);
                }
                LauncherModel.addOrMoveItemInDatabase(mLauncher, si, mInfo.id, si.screen, si.cellX,
                        si.cellY);
            }
        }
    }
    /* YUNOS END */

    public void onRemove(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        View v = getViewForInfo(item);
        Log.d(TAG, "sxsexe------->onRemove  mContent.childCount " + mContent.getChildCount() + " getItemCount " + getItemCount() + " item "
                + item);
        if (item.isEditFolderShortcut() && mHasDirtyData) {
            //if one item is drag to delete and remove EditFolderShortcut at the same time, do not reset mHasDirtyData 
        } else {
            mHasDirtyData = false;
        }
        mDestroyed = false;
        //BugID:5641318:IndexOutOfBoundsException in folder remove item
        if ((item.container >= 0) && (mContentList.size() > item.screen)) {
            mContentList.get(item.screen).removeView(v);
        } else {
            Log.d(TAG, "the item is changed. id is " + item.id + " screen is:" + item.screen + " container is:" + item.container);
            for (CellLayout cell: mContentList) {
                cell.removeView(v);
            }
        }
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            setupContentForNumItems(getItemCount());
        }
        /*YUNOS BEGIN*/
        //##date:2014/06/27 ##author:yangshan.ys##BugID:133402
        //batch operation to icons in folder may lead to the overlap of icon in workspace
        if (getItemCount() <= 1 && !mLauncher.getDragController().isDragging()
                && !mLauncher.isDragToDelete()
                && mNeedReplaceFolderWithFinalItem) {
            /* YUNOS BEGIN */
            // ## date: 2016/08/12 ## author: yongxing.lyx
            // ## BugID:8680304:icon duplicate after recategerAndSort.
			/* YUNOS BEGIN */
            // ##date:2016/12/23 ##author:wb-sl248920##9598014
		    // ##Desc: if Launcher has ReplaceFolder don't do again
            if (!LauncherModel.isInProcess() && !mLauncher.mHasReplaceFolder) {
                replaceFolderWithFinalItem();
            }
			/* YUNOS END */
            /* YUNOS BEGIN */
            this.setNeedReplaceFolderWithFinalItemFlase();
        }
        /* YUNOS END */
    }

    private View getViewForInfo(ShortcutInfo item) {
        for (int screen = 0; screen < mContentList.size(); screen++) {
            CellLayout mContent = mContentList.get(screen);
            for (int j = 0; j < mContent.getCountY(); j++) {
                for (int i = 0; i < mContent.getCountX(); i++) {
                    View v = mContent.getChildAt(i, j);
                    if (v == null) {
                        continue;
                    }
                    if (v.getTag() == item) {
                        return v;
                    }
                }
            }
        }
        return null;
    }

    public void onItemsChanged() {
        updateTextViewFocus();
    }

    public void invalidateFolder(View v, ShortcutInfo info) {
        // child view attached, do nothing
    }

    public void onTitleChanged(CharSequence title) {
    }

    public ArrayList<View> getItemsInReadingOrder() {
        return getItemsInReadingOrder(true);
    }

    public ArrayList<View> getItemsInReadingOrder(boolean includeCurrentDragItem) {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            int screenCount = mContentList.size();
            for (int m = 0; m < screenCount; m++) {
                CellLayout mContent = mContentList.get(m);
                for (int j = 0; j < mContent.getCountY(); j++) {
                    for (int i = 0; i < mContent.getCountX(); i++) {
                        View v = mContent.getChildAt(i, j);
                        if (v != null) {
                            mItemsInReadingOrder.add(v);
                        }
                    }
                }
            }
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public void getLocationInDragLayer(int[] loc) {
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName && hasFocus) {
            startEditingFolderName();
            /*YUNOS BEGIN*/
            //##module(component name)
            //##date:2014/03/27 ##author:jun.dongj@alibaba-inc.com##BugID:105282
            //when folder is open, the title outline disappear, and when folder title is click,the title outline appear
            showFolderNameOutline(true);
        }else{
            showFolderNameOutline(false);
            /*YUNOS END*/
        }
    }
    
    public FolderIcon getmFolderIcon() {
        return mFolderIcon;
    }
    
    /* YUNOS BEGIN */
    // ##date:2014/2/10 ##author:yaodi.yd
    // add a getter for field mState
    public int getState() {
    	return mState;
    }
    
    public void setState(int mState) {
    	this.mState = mState;
    }

    /**
     * Note that this method returns the <strong>current</strong> page
     * of this folder.
     * <p/>
     * To retrieve all the child views, use {@link #getItemCount()}
     * and {@link #getItemAt(int)} instead.
     */
	public CellLayout getContent() {
		return mContent;
	}

    private void setContent(CellLayout mContent) {
		this.mContent = mContent;
	}
    /* YUNOS END*/
    /* YUNOS BEGIN */
    // ##date:2014/06/03 ##author:yangshan.ys
    // batch operations to the icons in folder
    //close the appselectview
	public void closeSelectApps() {
	    if(mRunningAnimatorSet != null) {
            mRunningAnimatorSet.end();
        }
        this.setVisibility(View.VISIBLE);
        if (mAppsSelectView != null) {
            mLauncher.getDragLayer().removeView(mAppsSelectView);
            mAppsSelectView.removeAllViews();
            mAppsSelectView = null;
        }
    }
    public void backFromSelectApps() {
        if(mRunningAnimatorSet != null) {
            if(mRunningIsShow) {
                mRunningAnimatorSet.end();
            } else {
                return;
            }
        }
        ObjectAnimator invisToVis = ObjectAnimator.ofFloat(this, "alpha", 0, 1);
        invisToVis.setDuration(mAnimatorDuration);
        ObjectAnimator visToInvisX = ObjectAnimator.ofFloat(mAppsSelectView, "scaleX", 1, 0);
        visToInvisX.setDuration(mAnimatorDuration);
        ObjectAnimator visToInvisY = ObjectAnimator.ofFloat(mAppsSelectView, "scaleY", 1, 0);
        visToInvisY.setDuration(mAnimatorDuration);
        List<Animator> animList = new ArrayList<Animator>();
        animList.add(invisToVis);
        animList.add(visToInvisX);
        animList.add(visToInvisY);
        final AnimatorSet as = new AnimatorSet();
        as.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animator) {
                Folder.this.setVisibility(View.VISIBLE);
                mRunningAnimatorSet = as;
                mRunningIsShow = false;
                /*YUNOS BEGIN*/
                //##date:2014/06/27 ##author:yangshan.ys@alibaba-inc.com##BugID:132255
                //when back to folder from folderappsselectview ,prevent the mFolderName from getting focus 
                mFolderName.setFocusable(false);
                /* YUNOS END */
            }
            @Override
            public void onAnimationEnd(Animator animator) {
                mRunningAnimatorSet = null;
                mRunningIsShow = false;
                mAppsSelectView.setVisibility(View.INVISIBLE);
                Folder.this.setVisibility(View.VISIBLE);
                /*YUNOS BEGIN*/
                //##date:2014/06/27 ##author:yangshan.ys@alibaba-inc.com##BugID:132255
                //when back to folder from folderappsselectview ,prevent the mFolderName from getting focus 
                mFolderName.setFocusable(true);
                /*YUNOS BEGIN*/
                //##date:2014/06/27 ##author:yangshan.ys@alibaba-inc.com##BugID:133680
                //when back to folder from folderappsselectview, the folderName cannot be changed
                mFolderName.setFocusableInTouchMode(true);
                /* YUNOS END */
                /* YUNOS END */
                mIsEditingName = false;
            }
        });
        as.playTogether(animList);
        as.start();
    }
    private boolean contains(List<ShortcutInfo> list, ShortcutInfo info) {
        for(ShortcutInfo shortinfo : list) {
            if(shortinfo.intent.equals(info.intent)){
                return true;
            }
        }
        return false;
    }
	//deal the selected shortcut,first find the added and removed shortcuts,then deal them separately
    public void dealNewSelectedApps(ArrayList<ShortcutInfo> selectedShortcuts) {
        List<ShortcutInfo> currentShortcuts = new ArrayList(mInfo.contents);
        if(mInfo.isEditFolderInContents()) {
            currentShortcuts.remove(mInfo.getmEditFolderShortcutInfo());
        }
        List<ShortcutInfo> addedShortcuts = new ArrayList<ShortcutInfo>();
        List<ShortcutInfo> removedShortcuts = new ArrayList<ShortcutInfo>();
        for(ShortcutInfo select : selectedShortcuts) {
            if(!contains(currentShortcuts,select)) {
                addedShortcuts.add(select);
            }
        }
        for(ShortcutInfo current : currentShortcuts) {
            if(!contains(selectedShortcuts,current)){
                removedShortcuts.add(current);
            }
        }
        Log.d(FolderAppsSelectView.LOG_TAG,
                "The apps amount added to folder is:" + addedShortcuts.size()
                        + ", detail is:" + addedShortcuts.toString());
        Log.d(FolderAppsSelectView.LOG_TAG,
                "The apps amount removed from folder is:"
                        + removedShortcuts.size() + ", detail is:"
                        + removedShortcuts.toString());
        //deal the new added icon
        Workspace workspace = mLauncher.getWorkspace();
        ArrayList<ItemInfo> addItems = new ArrayList<ItemInfo>();
        for(ShortcutInfo shortcut : addedShortcuts) {
            ShortcutInfo clone = shortcut.clone();
            addItems.add(clone);
            // LauncherModel.getSbgworkspaceitems().remove(shortcut);
            mInfo.add(shortcut);
        }
        workspace.removeItemsViewByItemInfo(addItems);
        workspace.updateWorkspaceAfterDelItems(addItems);
        //if one screen has no icon after this function, then remove it
        workspace.checkAndRemoveEmptyCell();
        //deal the removed icons
        if(selectedShortcuts.size() == 0) {
            removedShortcuts.remove(0);
        }
        if(removedShortcuts.size() < 1) {
            return;
        }
        long container = LauncherSettings.Favorites.CONTAINER_DESKTOP;
        List<ScreenPosition> emptyCellList = LauncherModel.findEmptyCellsAndOccupy(removedShortcuts.size());
        Log.d(FolderAppsSelectView.LOG_TAG,
                "The amount of empty Cells found is " + emptyCellList.size()
                        + " ,detail is : " + emptyCellList.toString());
        if(emptyCellList == null || emptyCellList.size() == 0) {
            Log.d(FolderAppsSelectView.LOG_TAG,
                    "Have not the empty cell to place the apps in folder");
            Toast.makeText(mLauncher, getContext().getText(R.string.over_max_screen_count), Toast.LENGTH_SHORT).show();
            return;
        }
        for(int i = 0; i < emptyCellList.size(); i++) {
            ScreenPosition pos = emptyCellList.get(i);
            ShortcutInfo shortcut = removedShortcuts.get(i);
            mInfo.remove(shortcut);
            //the empty position is in the new screen
            if (pos.s >= workspace.getIconScreenCount()) {
                //if addEmptyScreen fail,then return
                if(!workspace.addEmptyScreenSync()) {
                    Toast.makeText(mLauncher, getContext().getText(R.string.over_max_screen_count), Toast.LENGTH_SHORT).show();
                    break;
                }
            }
            //add the icon to the workspace
            CellLayout cell = (CellLayout) workspace.getChildAt(pos.s);
            shortcut.cellX = pos.x;
            shortcut.cellY = pos.y;
            shortcut.container = container;
            shortcut.screen = pos.s;

            View view = mLauncher.createShortcut(R.layout.application, cell,shortcut);
            workspace.addInScreen(view, container, pos.s, pos.x, pos.y, shortcut.spanX,
                    shortcut.spanY, false);
            cell.onDropChild(view);
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
            cell.getShortcutAndWidgetContainer().measureChild(view);
            LauncherModel.addOrMoveItemInDatabase(mLauncher, shortcut, container, pos.s, lp.cellX, lp.cellY);
            Log.d(FolderAppsSelectView.LOG_TAG, "The app:" + shortcut.title
                    + " has moved to workspace ,the pos is " + pos.toString());
        }
        if(emptyCellList.size() < removedShortcuts.size()) {
            Toast.makeText(mLauncher, getContext().getText(R.string.over_max_screen_count), Toast.LENGTH_SHORT).show();
        }
        //if one screen has no icon after this function, then remove it
        workspace.checkAndRemoveEmptyCell();
    }
    public FolderAppsSelectView getmAppsSelectView() {
        return mAppsSelectView;
    }
    /* YUNOS END */

    /**
     * Minus folder title height to make drag out of Folder easier
     * Added by wenliang.dwl, BugID:5194368
     */
    @Override
    public void getHitRect(Rect outRect) {
        super.getHitRect(outRect);
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)mFolderName.getLayoutParams();
        outRect.top += mFolderName.getHeight() + lp.bottomMargin;
        /* YUNOS BEGIN */
        // ##date:2014/09/23 ##author:andy.zx ##BugID:5244732
        outRect.left = 0;
        outRect.right = mDisplaySize.x;
        // ##date:2015-1-22 ##author:zhanggong.zg ##BugID:5645766
        outRect.bottom -= mContentList.get(0).getPaddingBottom();
        /* YUNOS END */
        /* YUNOS BEGIN */
        // ##date:2015/1/30 ##author:zhanggong.zg ##BugID:5744899
        // Enables dragging icon out of folder through left and right edge.
        if (mDraggingToLeftEdge) {
            outRect.left = getLeft() + getResources().getDimensionPixelSize(R.dimen.scroll_zone);
        }
        if (mDraggingToRightEdge) {
            outRect.right = getRight() - getResources().getDimensionPixelSize(R.dimen.scroll_zone);
        }
        /* YUNOS END */
    }

    /* YUNOS BEGIN */
    // ##date:2014/9/25 ##author:yangshan.ys BugId:5255762
    final String HOR_LOG_TAG = "HorizFolder";

    /*YUNOS BEGIN*/
    //xiaodong.lxd  2015-01-15   BugID:5711526
    public int getMarkNumCount() {
        ShortcutAndWidgetContainer container = null;
        int markNumCount = 0;
        for (CellLayout mContent : mContentList) {
            container = mContent.getShortcutAndWidgetContainer();
            for (int i = 0, N = container.getChildCount(); i < N; i++) {
                View v = container.getChildAt(i);
                if (!(v instanceof BubbleTextView))
                    continue;
                BubbleTextView bubble = (BubbleTextView) v;
                if (bubble.isCornerMarkVisible()) {
                    markNumCount += bubble.getCornerMarkNumber();
                }
            }
        }
        return markNumCount;
    }


    private void adjustContentListSize(int realNeedPageCount) {
        int currentCount = mContentList.size();
        int diff = Math.abs(currentCount - realNeedPageCount);
        for (int i = 0; i < diff; i++) {
            if (realNeedPageCount > currentCount) {
                addNewCellLayout();
            } else {
                mContentList.remove(mContentList.size() - 1);
            }
        }
        if (realNeedPageCount > currentCount) {
            updateFolderLayout(isSupportCardIcon());
        }
        if (diff != 0 || mPageIndicator.getMax() != realNeedPageCount) {
            for (int i = 1, count = mContentList.size(); i < count; i++) {
                mContentList.get(i).setHasChanged(true);
            }
            mFolderViewPager.setAdapter(mContentAdapter);
            // do not show indicator when page count is one
            mPageIndicator.setMax(realNeedPageCount == 1 ? 0 : realNeedPageCount);
            mPageIndicator.setCurrentPos(0);
            mPageIndicator.invalidate();
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        // steal child's(ViewPager) touch event when animating
        return mState == STATE_ANIMATING ? true : super.onInterceptTouchEvent(ev);
    }

    private int getMaxItemsCountPerPage() {
        mMaxCountY = ConfigManager.getFolderMaxCountY();
        return mMaxCountX * mMaxCountY;
    }

    private CellLayout addNewCellLayout() {
        CellLayout cellLayout = (CellLayout) mInflater.inflate(R.layout.folder_page, null);
        cellLayout.setGridSize(0, 0);
        cellLayout.getShortcutAndWidgetContainer().setMotionEventSplittingEnabled(false);
        cellLayout.setInvertIfRtl(true);
        mContentList.add(cellLayout);
        return cellLayout;
    }

    class FolderContentAdapter extends PagerAdapter {
        @Override
        public int getCount() {
            return mContentList.size();
        }

        @Override
        public boolean isViewFromObject(View arg0, Object arg1) {
            return arg0 == arg1;
        }

        @Override
        public int getItemPosition(Object object) {
            if (((CellLayout) object).hasChanged()) {
                ((CellLayout) object).setHasChanged(false);
                return POSITION_NONE;
            } else {
                return super.getItemPosition(object);
            }
        }

        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            container.addView(mContentList.get(position));
            return mContentList.get(position);
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            if (position >= mContentList.size()) {
                container.removeView((View) object);
                return;
            }
            container.removeView(mContentList.get(position));
        }

        @Override
        public void setPrimaryItem(ViewGroup container, int position, Object object) {
            setContent((CellLayout) object);
        }
    };
    FolderSelectPager.OnPageChangeListener pageChangeListener = new FolderSelectPager.OnPageChangeListener() {
        @Override
        public void onPageSelected(int newPage) {
            // TODO indicator change
            mPageIndicator.setCurrentPos(newPage);
            mScrolling = false;
        }
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            mScrolling = false;
        }
        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };

    public void switchToPage(int page) {
        Log.d(TAG, "switchToPage  page " + page);
        mFolderViewPager.setCurrentItem(page, true);
    }

    public void switchToPage(int page, boolean anim) {
        mFolderViewPager.setCurrentItem(page, anim);
    }
   
    //xiaodong.lxd 2015-01-16  BugID:5235465
    public void updateFolderNameWithRemainedApp(ItemInfo item) {
        String originalFolderName = item.title + getResources().getString(R.string.folder_name_etc);
        String actualFolderName = mFolderName.getText().toString();
        if (originalFolderName.equals(actualFolderName)) {
            ShortcutInfo firstItem = (ShortcutInfo) mContentList.get(0).getChildAt(0, 0).getTag();
            String newFolderName = firstItem.title + getResources().getString(R.string.folder_name_etc);
            mInfo.setTitle(newFolderName);
            updateFolderName(newFolderName);
        }
    }

    Animator moveAnim = null;
    private void autoMoveIconByScroll(int srcPageIndex, int desPageIndex) {
        /*
         * xiaodong.lxd added , if the drag item belongs to this screen which is
         * not full, do not trigger move animation
         */
        if (mCurrentDragInfo != null && mCurrentDragInfo.screen == desPageIndex) {
            CellLayout cellLayout = mContentList.get(desPageIndex);
            if (cellLayout.getShortcutAndWidgetContainer().getChildCount() < getMaxItemsCountPerPage()) {
                return;
            }
        }

        mScrolling = true;
        cancelMoveAnimation();
        final CellLayout srcPage = mContentList.get(srcPageIndex);
        final CellLayout desPage = mContentList.get(desPageIndex);
        View movedView = null;
        // scroll left
        if (srcPageIndex > desPageIndex) {
            for (int j = desPage.getCountY() - 1; j >= 0; j--) {
                for (int i = desPage.getCountX() - 1; i >= 0; i--) {
                    if ((movedView = desPage.getChildAt(i, j)) != null) {
                        if (isEditIcon(movedView)) {
                            movedView = null;
                            break;
                        }
                        moveAnim = ObjectAnimator.ofFloat(movedView, TRANSLATION_X, LauncherApplication.getScreenWidth() - movedView.getX() + 100);
                        break;
                    }
                }
                if (movedView != null) {
                    break;
                }
            }
        } else {
            // scroll right
            for (int j = 0; j < desPage.getCountY(); j++) {
                for (int i = 0; i < desPage.getCountX(); i++) {
                    if ((movedView = desPage.getChildAt(i, j)) != null) {
                        if (isEditIcon(movedView)) {
                            movedView = null;
                            break;
                        }
                        moveAnim = ObjectAnimator.ofFloat(movedView, TRANSLATION_X, -300);
                        break;
                    }
                }
                if (movedView != null) {
                    break;
                }
            }
        }
        if (movedView == null) {
            return;
        }
        final ItemInfo movedInfo = (ItemInfo) movedView.getTag();
        final View view = movedView;
        mReorderAlarm.cancelAlarm();
        moveAnim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                view.setTranslationX(0);
                desPage.removeView(view);
                ViewParent parent = (view.getParent());
                if (parent != null) {
                    String title = "";
                    if (movedInfo != null) {
                        title = movedInfo.title.toString();
                    }
                    Log.e(HOR_LOG_TAG, "The icon:" + title
                            + ",has the parent when end on autoScroll,remove");
                    return;
                }
                CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
                int movedFromX = movedInfo.cellX;
                int movedFromY = movedInfo.cellY;
                lp.cellX = movedInfo.cellX = mEmptyCell[0];
                lp.cellY = movedInfo.cellY = mEmptyCell[1];
                mEmptyCell[0] = movedFromX;
                mEmptyCell[1] = movedFromY;
                boolean insert = false;
                srcPage.addViewToCellLayout(view, insert ? 0 : -1, (int) movedInfo.id, lp, true);
                // force to reorder
                mReorderAlarm.cancelAlarm();
                mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                mReorderAlarm.setAlarm(150);
            }
        });
        moveAnim.setDuration(300);
        moveAnim.start();
    }
    /* YUNOS END */
    Comparator<ShortcutInfo> infoDownComp = new Comparator<ShortcutInfo>() {
        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            // TODO Auto-generated method stub
            if (lhs.screen != rhs.screen) {
                return rhs.screen - lhs.screen;
            } else if (lhs.cellY != rhs.cellY) {
                return rhs.cellY - lhs.cellY;
            } else {
                return rhs.cellX - lhs.cellX;
            }
        }
    };

    private boolean isEditIcon(View v) {
        if (v != null && v.getTag() == mInfo.getmEditFolderShortcutInfo()) {
            return true;
        }
        return false;
    }

    /* YUNOS BEGIN */
    // ## date: 2016/06/20 ## author: yongxing.lyx
    // ## BugID:8431132:default folder auto change title when language changed.
    public CharSequence getDisplayTitle(Context context) {
        CharSequence title = mInfo.title;
        Resources res = context.getResources();

        if (sDefaultFolderName.contentEquals(mInfo.title)) {
            title = res.getString(R.string.folder_hint_text);
        } else {
            title = mInfo.getDisplayTitle(context);
        }
        return title;
    }
    /* YUNOS END */
}
